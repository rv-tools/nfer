package nfer

import scala.io.Source
import nfer.ast.{NferParser, Rule}
import nfer.repr._
import Util._

// TODO: Real publish subscribe service

private[nfer] class Agent(bus: Bus)(rule: Rule) {
  val ruleRepr = RuleAstToRuleRepr(rule)
  ruleRepr.setCallBack(bus.publish)
  ruleRepr.getIntervalNames foreach (bus.subscribe(this, _))
  bus.recordAgent(this)

  Agent.getDotFile match {
    case None =>
    case Some(dotfile) =>
      ruleRepr.setDotFile(dotfile)
  }

  def receive(interval: Interval) {
    ruleRepr.addInterval(interval)
  }

  def getIntervals: List[Set[Interval]] = ruleRepr.getIntervals
}

private[nfer] object Agent {
  private var counter: Int = 0
  private var dotFileRoot: String = null

  def setDotFileRoot(root: String): Unit = {
    dotFileRoot =
      if (root.endsWith("/"))
        root
      else root + "/"
  }

  def getDotFile: Option[String] = {
    if (dotFileRoot == null) None
    else {
      counter += 1
      Some(s"$dotFileRoot$counter.dot")
    }
  }
}

private[nfer] class Bus {
  private var subscribers: Map[IntervalName, Set[Agent]] = Map()
  private var agents: Map[IntervalName, Agent] = Map()
  private var delayFlag: Boolean = false

  def setDelay(value: Boolean): Bus = {
    delayFlag = value
    this
  }

  def delay(): Unit = {
    print(">")
    System.in.read()
  }

  def getSubscribers(intervalName: IntervalName): Set[Agent] = {
    subscribers.getOrElse(intervalName, Set())
  }

  def subscribe(agent: Agent, intervalName: String): Unit = {
    val agentSet = getSubscribers(intervalName)
    subscribers += (intervalName -> (agentSet + agent))
  }

  def recordAgent(agent: Agent): Unit = {
    agents = agents + (agent.ruleRepr.getTopNode.name -> agent)
  }

  def getAgent(name: IntervalName): Agent =
    agents(name)

  def getIntervals: Map[IntervalName,Set[Interval]] = {
    agents map {
      case (name,agent) => (name -> agent.getIntervals.head)
    }
  }

  // to be called from agents

  def publish(interval: Interval): Unit = {
    //println(s"Publishing $interval")
    for (agent <- getSubscribers(interval.name))
      agent.receive(interval)
  }

  // to be called from outside

  def submit(interval: Interval): Unit = {
    if (delayFlag) delay()
    publish(interval)
  }
}

/**
  * Representation of intervals generated by nfer.
  *
  * @param name  name of interval.
  * @param begin begin time-stamp of interval in seconds.
  * @param end   end time-stamp of interval in seconds.
  * @param data  data carried by interval.
  */

case class Interval(name: String, begin: Sclk, end: Sclk, data: Map[String, Any]) {
  def contains(other: Interval): Boolean = {
    name == other.name &&
      ((begin < other.begin && other.end <= end) ||
        (begin <= other.begin && other.end < end))
  }

  def isAtomic: Boolean = begin == end

  def toStringForTest: String = {
    def quote(str: String) = "\"" + str + "\""
    val nameQuoted = quote(name)
    val dataQuoted = data map {
      case (n,v) => (quote(n) -> (if (v.isInstanceOf[String]) quote(v.asInstanceOf[String]) else v))
    }
    s"Interval($nameQuoted,$begin,$end,$dataQuoted)"
  }

  def toStringCompressed: String = {
    val datamap = data.map(pair => s"${pair._1}:${pair._2}")
    s"($name,$begin,$end,[${datamap.mkString(",")}])"
  }

  override def toString: String = {
    def quote(str: String) = "\"" + str + "\""
    val nameQuoted = quote(name)
    val dataQuoted = data map {
      case (n,v) => (quote(n) -> (if (v.isInstanceOf[String]) quote(v.asInstanceOf[String]) else
        if (v.isInstanceOf[Double]) f"${v.asInstanceOf[Double]}%.5f" else v))
    }
    f"Interval($nameQuoted,$begin%.5f,$end%.5f,$dataQuoted)"
  }
}

/**
  * User defined operations. A user must define a sub-class of this trait overriding the apply function.
  */

trait Operation {
  def apply(args: Any*): Any
}

/**
  * Class offering features for writing nfer specifications and applying them to a
  * traces of events.
  */

class Nfer {
  private val bus = new Bus()

  /**
    * Option: when true submitted intervals will get printed.
    */

  var PRINT_SUBMIT : Boolean = false

  /**
    * Sets the minimality option to the value provided.
    * If true minimality will be applied (the default value).
    *
    * @param value true if minimality is to be applied.
    */

  def setMinimality(value: Boolean): Unit = {
    MINIMALITY = value
  }

  /**
    * Sets the directory where dot files are stored. The nfer tool can produce a visualization
    * of the network for each rule that is generated. The generated dot files can be viewed with
    * GraphViz. Keep the files open and watch the network for each rule getting updated.
    *
    * @param dotDir the total path to directory where dot files should be stored.
    * @return a reference to the original Nfer object, the value 'this'. This allows chaining such calls.
    */

  def dotDir(dotDir: String): Nfer = {
    Agent.setDotFileRoot(dotDir)
    this
  }

  /**
    * Sets the delay flag. When true, after submission of an event, nfer will wait for the user
    * to type RETURN (CR) on the input stream before nfer continues to process the next interval submitted
    * to it. This allows a user to observe how the network for each rule is populated with
    * intervals.
    *
    * @param flag when true nfer waits for the user to enter RETURN for each event.
    * @return a reference to the original Nfer object, the value 'this'. This allows chaining such calls.
    */

  def delay(flag: Boolean): Nfer = {
    bus.setDelay(flag)
    this
  }

  /**
    * Initializes the monitor with a specification provided as a text string directly.
    *
    * @param text the nfer specification.
    * @return a reference to the original Nfer object, the value 'this'. This allows chaining such calls.
    */

  def specText(text: String): Nfer = {
    val specAST = NferParser(text)

    for (rule <- specAST.getRules) {
      new Agent(bus)(rule)
    }
    this
  }

  /**
    * Initializes the monitor with a specification provided in a text file.
    *
    * @param fileName the name of the file containing the nfer specification.
    * @return a reference to the original Nfer object, the value 'this'. This allows chaining such calls.
    */

  def specFile(fileName: String): Nfer = {
    val text = Source.fromFile(fileName).getLines.mkString("\n")
    specText(text)
  }

  /**
    * Reading from a file. Useful for reading events from a log for example.
    */

  def readFromFile(fileName: String): Iterator[String] =
    Source.fromFile(fileName).getLines

  /**
    * Timing the execution of a block of code.
    *
    * @param block the block to be timed
    * @tparam R the result type of the block
    * @return the returned result
    */

  def time[R](block: => R): R = {
    val t0 = System.currentTimeMillis()
    val result = block    // call-by-name
    val t1 = System.currentTimeMillis()
    println("Elapsed time: " + (t1 - t0) + "ms")
    result
  }

  /**
    * Adds a user defined operation to the operation store. Such operations can be called with
    * the standard syntax: name(exp1,...,expn).
    *
    * @param name      name of operation.
    * @param operation the operation being added.
    */

  def addOperation(name: String)(operation: Operation): Unit = {
    ExpressionEvaluation.operationStore.add(name)(operation)
  }

  /**
    * Submit a trace consisting of intervals to the monitor.
    *
    * @param intervals the trace of intervals.
    */

  def submit(intervals: List[Interval]): Unit = {
    for (interval <- intervals) {
      submit(interval)
    }
  }

  /**
    * Submits an interval to the monitor.
    *
    * @param interval the interval submitted.
    */

  def submit(interval: Interval): Unit = {
    if (PRINT_SUBMIT) println(s"Submitting $interval")
    bus.submit(interval)
  }

  /**
    * Submits an atomic interval (an event where begin time and end time are the same) by enumerating its parts.
    *
    * @param name the name of the interval.
    * @param time the time of the event.
    * @param data the data of the event provided as a map.
    */

  def submit(name: String, time: Sclk, data: Data): Unit = {
    submit(Interval(name, time, time, data))
  }

  /**
    * Submits an atomic interval (an event where begin time and end time are the same) by enumerating its parts,
    * and providing the data as variable arguments.
    *
    * @param name the name of the interval.
    * @param time the time of the event.
    * @param data the data of the event provided as variable arguments.
    */

  def submit(name: String, time: Sclk, data: (String, Any)*) {
    submit(name, time, data.toMap)
  }

  /**
    * Returns the intervals stored in the tree representing a rule. The nodes of the tree is visited
    * using breath-first search, resulting in a list of interval sets, one set for each (sub-)node visited.
    * This function can be used for testing.
    *
    * @param name right-hand side name of rule.
    * @return the list of interval sets of nodes visited depth-first.
    */

  def getIntervalsInTree(name: IntervalName): List[Set[Interval]] =
    bus.getAgent(name).getIntervals

  /**
    * Returns a map which maps each rule name to the set of intervals it has published.
    *
    * @return the map from rule names to published intervals.
    */

  def getIntervalMap: Map[IntervalName,Set[Interval]] =
    bus.getIntervals

  /**
    * Prints the intervals produced in a run.
    *
    * @param allIntervals true when each detected interval should be printed, and false if only
    *                     the number of different intervals should be printed.
    */

  def printIntervals(allIntervals: Boolean = true): Unit = {
    println()
    println("=================================")
    println("    Generated Intervals:")
    println("---------------------------------")
    for ((i, s) <- getIntervalMap) {
        println(s"$i : ${s.size}")
      if (!s.isEmpty && allIntervals) {
        for (e <- s) println(s"  $e")
      }
    }
    println("---------------------------------")
  }
}
